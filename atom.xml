<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jeremy Blog</title>
  
  <subtitle>天才小陶的技术随笔</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-06T06:48:38.144Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jeremy Tao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java集合框架</title>
    <link href="http://yoursite.com/2020/07/06/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2020/07/06/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</id>
    <published>2020-07-06T06:50:11.814Z</published>
    <updated>2020-07-06T06:48:38.144Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">title: Java集合框架</span><br><span class="line">date: <span class="number">2020</span>-<span class="number">07</span>-<span class="number">06</span> <span class="number">14</span>:<span class="number">48</span></span><br><span class="line">tags:集合框架</span><br><span class="line">- 博客         </span><br><span class="line">- hexo</span><br><span class="line">categories: Java</span><br></pre></td></tr></table></figure><h2 id="一、Java集合框架概述"><a href="#一、Java集合框架概述" class="headerlink" title="一、Java集合框架概述"></a><strong>一、Java集合框架概述</strong></h2><p>构是以某种形式将数据组织在一起的集合，它不仅存储数据，还支持访问和处理数据的操作。Java提供了几个能有效地组织和操作数据的数据结构，这些数据结构通常称为Java集合框架。集合可以看作是一种容器，用来存储对象信息。所有集合类都位于java.util包下，但支持多线程的集合类位于<strong>java.util.concurrent</strong>包下。</p><p><strong>数组与集合的区别如下</strong>：</p><p>1）数组长度不可变化而且无法保存具有映射关系的数据；集合类用于保存数量不确定的数据，以及保存具有映射关系的数据。</p><p>2）数组元素既可以是基本类型的值，也可以是对象；集合只能保存对象。</p><p>Java集合类主要由两个根接口<strong>Collection</strong>和<strong>Map</strong>派生出来的，Collection派生出了三个子接口：List、Set、Queue（Java5新增的队列），因此Java集合大致也可分成List、Set、Queue、Map四种接口体系，（<strong>注意：Map不是Collection的子接口</strong>）。</p><p>Java集合框架图如下：</p><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2019/10/14/16dc8ee74157e0ab?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2019/10/14/16dc8ee741612be7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>其中List代表了有序可重复集合，可直接根据元素的索引来访问；Set代表无序不可重复集合，只能根据元素本身来访问；Queue是队列集合；Map代表的是存储key-value对的集合，可根据元素的key来访问value。</p><p>  上图中淡绿色背景覆盖的是集合体系中常用的实现类，分别是ArrayList、LinkedList、ArrayQueue、HashSet、TreeSet、HashMap、TreeMap等实现类。</p><h2 id="二、Java集合常见接口及实现类"><a href="#二、Java集合常见接口及实现类" class="headerlink" title="二、Java集合常见接口及实现类"></a><strong>二、Java集合常见接口及实现类</strong></h2><p><strong>1. Collection接口常见方法（来源于Java API）</strong></p><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2019/10/14/16dc8ee7424953f8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><strong>2. Set集合</strong></p><p>  Set集合与Collection的方法相同，由于Set集合不允许存储相同的元素，所以如果把两个相同元素添加到同一个Set集合，则添加操作失败，新元素不会被加入，add()方法返回false。为了帮助理解，请看下面代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">   Set&lt;String&gt; set&#x3D;new HashSet();</span><br><span class="line">   set.add(&quot;hello world&quot;);</span><br><span class="line">   set.add(&quot;hello 冰湖一角&quot;);</span><br><span class="line">   set.add(&quot;hello 冰湖一角&quot;);</span><br><span class="line">   System.out.println(&quot;集合中元素个数：&quot;</span><br><span class="line">        +set.size());</span><br><span class="line">   System.out.println(&quot;集合中元素为：&quot;</span><br><span class="line">       +set.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&lt;&#x2F;pre&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p>集合中元素个数：2 集合中元素为：[hello world, hello 冰湖一角]</p><p>分析：由于String类中重写了hashCode()和equals()方法，用来比较指向的字符串对象所存储的字符串是否相等。所以这里的第二个”hello 冰湖一角”是加不进去的。</p><p>下面着重介绍Set集合几个常用实现类：</p><p><strong>1）HashSet类</strong></p><p>HashSet是Set集合最常用实现类，是其经典实现。HashSet是按照hash算法来存储元素的，因此具有很好的存取和查找性能。</p><p>HashSet具有如下特点：</p><p>♦ 不能保证元素的顺序。</p><p>♦ HashSet不是线程同步的，如果多线程操作HashSet集合，则应通过代码来保证其同步。</p><p>♦ 集合元素值可以是null。</p><p>HashSet存储原理如下：</p><p>当向HashSet集合存储一个元素时，HashSet会调用该对象的hashCode()方法得到其hashCode值，然后根据hashCode值决定该对象的存储位置。HashSet集合判断两个元素相等的标准是(1)两个对象通过equals()方法比较返回true；(2)两个对象的hashCode()方法返回值相等。因此，如果(1)和(2)有一个不满足条件，则认为这两个对象不相等，可以添加成功。如果两个对象的hashCode()方法返回值相等，但是两个对象通过equals()方法比较返回false，HashSet会以链式结构将两个对象保存在同一位置，这将导致性能下降，因此在编码时应避免出现这种情况。</p><p>HashSet查找原理如下：</p><p>基于HashSet以上的存储原理，在查找元素时，HashSet先计算元素的HashCode值（也就是调用对象的hashCode方法的返回值），然后直接到hashCode值对应的位置去取出元素即可，这就是HashSet速度很快的原因。</p><p>重写hashCode()方法的基本原则如下：</p><p>♦ 在程序运行过程中，同一个对象的hashCode()方法返回值应相同。</p><p>♦ 当两个对象通过equals()方法比较返回true时，这两个对象的hashCode()方法返回值应该相等。</p><p>♦ 对象中用作equals()方法比较标准的实例变量，都应该用于计算hashCode值。</p><p><strong>2）LinkedHashSet类</strong></p><p>LinkedHashSet是HashSet的一个子类，具有HashSet的特性，也是根据元素的hashCode值来决定元素的存储位置。但它使用链表维护元素的次序，元素的顺序与添加顺序一致。由于LinkedHashSet需要维护元素的插入顺序，因此性能略低于HashSet，但在迭代访问Set里的全部元素时由很好的性能。</p><p><strong>3）TreeSet类</strong></p><p>TreeSet时SortedSet接口的实现类，TreeSet可以保证元素处于排序状态，它采用红黑树的数据结构来存储集合元素。TreeSet支持两种排序方法：自然排序和定制排序，默认采用自然排序。</p><p><strong>♦ 自然排序</strong></p><p>TreeSet会调用集合元素的compareTo(Object obj)方法来比较元素的大小关系，然后将元素按照升序排列，这就是自然排序。如果试图将一个对象添加到TreeSet集合中，则该对象必须实现Comparable接口，否则会抛出异常。当一个对象调用方法与另一个对象比较时，例如obj1.compareTo(obj2)，如果该方法返回0，则两个对象相等；如果返回一个正数，则obj1大于obj2；如果返回一个负数，则obj1小于obj2。</p><p>Java常用类中已经实现了Comparable接口的类有以下几个：</p><p>♦ BigDecimal、BigDecimal以及所有数值型对应的包装类：按照它们对应的数值大小进行比较。</p><p>♦ Charchter：按照字符的unicode值进行比较。</p><p>♦ Boolean：true对应的包装类实例大于false对应的包装类实例。</p><p>♦ String：按照字符串中的字符的unicode值进行比较。</p><p>♦ Date、Time：后面的时间、日期比前面的时间、日期大。</p><p>对于TreeSet集合而言，它判断两个对象是否相等的标准是：两个对象通过compareTo(Object obj)方法比较是否返回0，如果返回0则相等。</p><p><strong>♦ 定制排序</strong></p><p>想要实现定制排序，需要在创建TreeSet集合对象时，提供一个Comparator对象与该TreeSet集合关联，由Comparator对象负责集合元素的排序逻辑。</p><p>综上：自然排序实现的是Comparable接口，定制排序实现的是Comparator接口。（具体代码实现会在后续章节中讲解）</p><p><strong>4）EnumSet类</strong></p><p>EnumSet是一个专为枚举类设计的集合类，不允许添加null值。EnumSet的集合元素也是有序的，它以枚举值在Enum类内的定义顺序来决定集合元素的顺序。</p><p><strong>5）各Set实现类的性能分析</strong></p><p>HashSet的性能比TreeSet的性能好（特别是添加，查询元素时），因为TreeSet需要额外的红黑树算法维护元素的次序，如果需要一个保持排序的Set时才用TreeSet，否则应该使用HashSet。</p><p>LinkedHashSet是HashSet的子类，由于需要链表维护元素的顺序，所以插入和删除操作比HashSet要慢，但遍历比HashSet快。</p><p>EnumSet是所有Set实现类中性能最好的，但它只能 保存同一个枚举类的枚举值作为集合元素。</p><p>以上几个Set实现类都是线程不安全的，如果多线程访问，必须手动保证集合的同步性，这在后面的章节中会讲到。</p><p><strong>3. List集合</strong></p><p>List集合代表一个有序、可重复集合，集合中每个元素都有其对应的顺序索引。List集合默认按照元素的添加顺序设置元素的索引，可以通过索引（类似数组的下标）来访问指定位置的集合元素。</p><p>实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。</p><p><strong>1）ArrayList</strong></p><p>ArrayList是一个动态数组，也是我们最常用的集合，是List类的典型实现。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。</p><p>ArrayList擅长于随机访问元，同时ArrayList是非同步的。</p><p><strong>2）LinkedList</strong></p><p>LinkedList是List接口的另一个实现，除了可以根据索引访问集合元素外，LinkedList还实现了Deque接口，可以当作双端队列来使用，也就是说，既可以当作“栈”使用，又可以当作队列使用。</p><p>LinkedList的实现机制与ArrayList的实现机制完全不同，ArrayLiat内部以数组的形式保存集合的元素，所以随机访问集合元素有较好的性能；LinkedList内部以链表的形式保存集合中的元素，所以随机访问集合中的元素性能较差，但在插入删除元素时有较好的性能。</p><p><strong>3）Vector</strong></p><p>与ArrayList相似，但是Vector是同步的。所以说Vector是线程安全的动态数组。它的操作与ArrayList几乎一样。</p><p><strong>4）Stack</strong></p><p>Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。</p><p><strong>5）Iterator接口和ListIterator接口</strong></p><p>Iterator是一个接口，它是集合的迭代器。集合可以通过Iterator去遍历集合中的元素。Iterator提供的API接口如下：</p><p>♦ boolean hasNext()：判断集合里是否存在下一个元素。如果有，hasNext()方法返回 true。 ♦ Object next()：返回集合里下一个元素。 ♦ void remove()：删除集合里上一次next方法返回的元素。</p><p>ListIterator接口继承Iterator接口，提供了专门操作List的方法。ListIterator接口在Iterator接口的基础上增加了以下几个方法：</p><p>♦ boolean hasPrevious()：判断集合里是否存在上一个元素。如果有，该方法返回 true。 ♦ Object previous()：返回集合里上一个元素。 ♦ void add(Object o)：在指定位置插入一个元素。</p><p>以上两个接口相比较，不难发现，ListIterator增加了向前迭代的功能（Iterator只能向后迭代），ListIterator还可以通过add()方法向List集合中添加元素（Iterator只能删除元素）。</p><p><strong>4. Map集合</strong></p><p>Map接口采用键值对Map&lt;K,V&gt;的存储方式，保存具有映射关系的数据，因此，Map集合里保存两组值，一组值用于保存Map里的key，另外一组值用于保存Map里的value，key和value可以是任意引用类型的数据。key值不允许重复，可以为null。如果添加key-value对时Map中已经有重复的key，则新添加的value会覆盖该key原来对应的value。常用实现类有HashMap、LinkedHashMap、TreeMap等。</p><p>Map常见方法（来源于API）如下：</p><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2019/10/14/16dc8ee74259b030?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><strong>1）HashMap与Hashtable</strong></p><p>HashMap与Hashtable是Map接口的两个典型实现，它们之间的关系完全类似于ArrayList与Vertor。HashTable是一个古老的Map实现类，它提供的方法比较繁琐，目前基本不用了，HashMap与Hashtable主要存在以下两个典型区别：</p><p>♦ HashMap是线程不安全，HashTable是线程安全的。</p><p>♦ HashMap可以使用null值最为key或value；Hashtable不允许使用null值作为key和value，如果把null放进HashTable中，将会发生空指针异常。</p><p>为了成功的在HashMap和Hashtable中存储和获取对象，用作key的对象必须实现hashCode()方法和equals()方法。</p><p>HashMap工作原理如下：</p><p>HashMap基于hashing原理，通过put()和get()方法存储和获取对象。当我们将键值对传递给put()方法时，它调用建对象的hashCode()方法来计算hashCode值，然后找到bucket位置来储存值对象。当获取对象时，通过建对象的equals()方法找到正确的键值对，然后返回对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会存储在链表的下一个节点中。</p><p><strong>2）LinkedHashMap实现类</strong></p><p>LinkedHashMap使用双向链表来维护key-value对的次序（其实只需要考虑key的次序即可），该链表负责维护Map的迭代顺序，与插入顺序一致，因此性能比HashMap低，但在迭代访问Map里的全部元素时有较好的性能。</p><p><strong>3）Properties</strong></p><p>Properties类时Hashtable类的子类，它相当于一个key、value都是String类型的Map，主要用于读取配置文件。</p><p><strong>4）TreeMap实现类</strong></p><p>TreeMap是SortedMap的实现类，是一个红黑树的数据结构，每个key-value对作为红黑树的一个节点。TreeMap存储key-value对时，需要根据key对节点进行排序。TreeMap也有两种排序方式：</p><p>♦ 自然排序：TreeMap的所有key必须实现Comparable接口，而且所有的key应该是同一个类的对象，否则会抛出ClassCastException。</p><p>♦ 定制排序：创建TreeMap时，传入一个Comparator对象，该对象负责对TreeMap中的所有key进行排序。</p><p><strong>5）各Map实现类的性能分析</strong></p><p>♦ HashMap通常比Hashtable（古老的线程安全的集合）要快</p><p>♦ TreeMap通常比HashMap、Hashtable要慢，因为TreeMap底层采用红黑树来管理key-value。</p><p>♦ LinkedHashMap比HashMap慢一点，因为它需要维护链表来爆出key-value的插入顺序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/07/01/hello-world/"/>
    <id>http://yoursite.com/2020/07/01/hello-world/</id>
    <published>2020-07-01T07:33:20.438Z</published>
    <updated>2020-07-01T07:33:20.438Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
